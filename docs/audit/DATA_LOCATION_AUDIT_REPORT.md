# Отчет о расположении данных в системе

**Дата аудита:** 2026-01-05  
**Дата обновления:** 2026-01-05  
**Скрипт:** `scripts/comprehensive-data-audit.ts`  
**Дополнительные скрипты:** `scripts/audit-users.ts`

## Результаты проверки синхронизации (2026-01-05)

**Скрипт проверки:** `scripts/verify-db-sync.ts`  
**Дата проверки:** 2026-01-05

### Текущее состояние данных

| Тип данных      | БД (SQL)           | Память                     | Расхождений | Статус                 |
| --------------- | ------------------ | -------------------------- | ----------- | ---------------------- |
| **Организации** | `organization` (0) | `memory.ORGANIZATIONS` (1) | 1           | ⚠️ Ожидаемое поведение |
| **Проекты**     | `pm_projects` (48) | `memory.PROJECTS` (0)      | 48          | ✅ Cache-aside паттерн |
| **Задачи**      | `pm_tasks` (38)    | `memory.TASKS` (0)         | 38          | ✅ Cache-aside паттерн |

**Всего расхождений:** 87

### Анализ результатов

#### Организации

- **В БД:** 0 организаций
- **В памяти:** 1 организация (`acct-collabverse`)
- **Причина расхождения:** Организация создается автоматически в БД только при обращении через `organizationsRepository.findById()`. Скрипт делает прямой SQL-запрос, поэтому организация не создается.
- **Статус:** ⚠️ Ожидаемое поведение - автоматическая синхронизация работает при использовании репозитория, но не при прямых SQL-запросах.

#### Проекты

- **В БД:** 48 проектов в `pm_projects`
- **В памяти:** 0 проектов
- **Причина расхождения:** Память используется как кэш (cache-aside паттерн). Репозиторий `projectsRepository.list()` читает из БД, память не загружается автоматически.
- **Статус:** ✅ Корректное поведение согласно архитектуре

#### Задачи

- **В БД:** 38 задач в `pm_tasks`
- **В памяти:** 0 задач
- **Причина расхождения:** Память используется как кэш (cache-aside паттерн). Репозиторий `tasksRepository.list()` читает из БД, память не загружается автоматически.
- **Статус:** ✅ Корректное поведение согласно архитектуре

### Сравнение с предыдущим аудитом (2026-01-05)

| Параметр             | Предыдущий аудит | Текущая проверка | Изменение        |
| -------------------- | ---------------- | ---------------- | ---------------- |
| Организации в БД     | 1                | 0                | ⚠️ Разница       |
| Организации в памяти | 1                | 1                | ✅ Без изменений |
| Проекты в БД         | 48               | 48               | ✅ Без изменений |
| Проекты в памяти     | 0                | 0                | ✅ Без изменений |
| Задачи в БД          | 38               | 38               | ✅ Без изменений |
| Задачи в памяти      | 0                | 0                | ✅ Без изменений |

**Вывод:** Количество данных в БД и памяти не изменилось. Разница в количестве организаций в БД объясняется тем, что в предыдущем аудите организация была создана через репозиторий, а текущая проверка использует прямой SQL-запрос.

### Важные замечания

1. **Расхождения не являются проблемой** - согласно архитектуре, память используется как кэш (cache-aside), а не как источник истины. Репозитории читают из БД напрямую.

2. **Организация синхронизируется автоматически** - при обращении через `organizationsRepository.findById('acct-collabverse')` организация автоматически создается в БД, если её там нет.

3. **Скрипт проверяет синхронизацию БД ↔ память** - это полезно для выявления проблем, но расхождения ожидаемы при использовании cache-aside паттерна.

4. **Рекомендация:** Скрипт `verify-db-sync.ts` можно использовать для мониторинга, но нужно учитывать, что расхождения между БД и памятью являются нормальными при cache-aside паттерне.

## Статус исправлений (2026-01-05)

### Выполненные критические исправления

✅ **Организация синхронизирована с БД**

- Создан скрипт `scripts/sync-organization-to-db.ts` для синхронизации
- Добавлена автоматическая синхронизация в `OrganizationsDbRepository.findById()`
- Организация `acct-collabverse` теперь создается в БД при первом обращении

✅ **Репозитории проектов читают из БД**

- `ProjectsRepository.list()` переведен на чтение из `pm_projects`
- Метод стал асинхронным, обновлены основные места использования
- Память используется только как кэш

✅ **Репозитории задач читают из БД**

- `TasksRepository.list()` переведен на чтение из `pm_tasks`
- Метод стал асинхронным, обновлены основные места использования
- Память используется только как кэш

✅ **Зафиксированы канонические таблицы**

- `pm_projects` и `pm_tasks` - единственные канонические таблицы
- Таблица `project` (Drizzle) помечена как `@deprecated`
- Создан [ADR-0001](../architecture/adr/0001-canonical-database-tables.md)

✅ **Документация обновлена**

- Создан `docs/architecture/database-architecture.md` - единое руководство
- Обновлены правила работы с БД в `.cursor/rules/database.mdc`
- Устаревшие документы перемещены в архив

### Текущий статус

| Тип данных       | БД (Drizzle)       | БД (SQL)           | Память                       | Репозиторий                   | Статус              |
| ---------------- | ------------------ | ------------------ | ---------------------------- | ----------------------------- | ------------------- |
| **Пользователи** | `user` (1)         | `user` (1)         | `memory.WORKSPACE_USERS` (1) | `usersRepository` (1)         | ✅ Синхронизировано |
| **Организации**  | `organization` (1) | `organization` (1) | `memory.ORGANIZATIONS` (1)   | `organizationsRepository` (1) | ✅ Синхронизировано |
| **Проекты**      | `project` (0)      | `pm_projects` (48) | `memory.PROJECTS` (кэш)      | `projectsRepository` (48)     | ✅ Читает из БД     |
| **Задачи**       | N/A                | `pm_tasks` (38)    | `memory.TASKS` (кэш)         | `tasksRepository` (38)        | ✅ Читает из БД     |

**Легенда:**

- ✅ Работает корректно
- ⚠️ Есть проблемы консистентности
- ❌ Не используется/не найдено

### Оставшиеся задачи

⚠️ **Унификация точек записи** - некоторые операции все еще используют прямые SQL-вставки
⚠️ **Полная реализация cache-aside** - кэш пока без TTL, нужна инвалидация при записи

## Контекст: Архитектура хранения данных

### 1. Пользователи (Users)

#### Что такое пользователь

Пользователь — это сущность, которая представляет человека в системе. Пользователь имеет:

- **ID**: UUID (`00000000-0000-0000-0000-000000000001` для администратора)
- **Email**: уникальный идентификатор (`admin.demo@collabverse.test`)
- **Имя**: отображаемое имя (`Алина Админ`)
- **Дополнительные поля**: title, department, location, passwordHash

#### Где хранятся данные пользователя

**Основное хранилище: БД (таблица `user`)**

Таблица создается через Drizzle миграцию `0000_lying_mauler.sql` и `0001_chemical_lake.sql`:

```sql
CREATE TABLE "user" (
  "id" text PRIMARY KEY NOT NULL,
  "name" text,
  "email" text UNIQUE,
  "emailVerified" timestamp,
  "image" text,
  "passwordHash" text,
  "title" text,
  "department" text,
  "location" text,
  "timezone" text,
  "createdAt" timestamp DEFAULT now(),
  "updatedAt" timestamp DEFAULT now()
);
```

**Дополнительное хранилище: Память (`memory.WORKSPACE_USERS`)**

Память используется для быстрого доступа и кэширования. Инициализируется в `apps/api/src/data/memory.ts`:

```typescript
export const WORKSPACE_USERS: WorkspaceUser[] = [
  {
    id: TEST_ADMIN_USER_ID, // '00000000-0000-0000-0000-000000000001'
    name: 'Алина Админ',
    email: 'admin.demo@collabverse.test',
    title: 'Руководитель продукта',
    department: 'Продукт',
    location: 'Москва',
  },
];
```

#### Как создается пользователь

1. **Регистрация через API** (`/api/auth/register`):
   - Создается через `usersRepository.create()`
   - Записывается в БД через Drizzle (`users` таблица)
   - Добавляется в память (`memory.WORKSPACE_USERS`)

2. **Инициализация демо-аккаунтов**:
   - При первом запуске создается администратор
   - ID: `00000000-0000-0000-0000-000000000001`
   - Email: `admin.demo@collabverse.test`

#### Результаты аудита пользователей

| ID                                     | Email                         | Имя           | Расположение    | Таблица БД | Ключ памяти              | Источник                 |
| -------------------------------------- | ----------------------------- | ------------- | --------------- | ---------- | ------------------------ | ------------------------ |
| `00000000-0000-0000-0000-000000000001` | `admin.demo@collabverse.test` | `Алина Админ` | **БД + Память** | `user`     | `memory.WORKSPACE_USERS` | Drizzle ORM + Direct SQL |

**Статус:** ✅ Пользователь синхронизирован между БД и памятью

### 2. Организации (Organizations)

#### Что такое организация

Организация — это группа пользователей, которая владеет проектами. Организация имеет:

- **ID**: текстовый идентификатор (`acct-collabverse`)
- **Owner ID**: ID пользователя-владельца
- **Название**: имя организации
- **Тип**: `closed` или `open`
- **Статус**: `active`, `archived`, `deleted`

#### Где хранятся данные организации

**Основное хранилище: БД (таблица `organization`)**

Таблица создается через Drizzle миграцию `0001_chemical_lake.sql`:

```sql
CREATE TABLE "organization" (
  "id" text PRIMARY KEY NOT NULL,
  "owner_id" text NOT NULL,
  "name" text NOT NULL,
  "description" text,
  "type" "organization_type" DEFAULT 'closed' NOT NULL,
  "is_public_in_directory" boolean DEFAULT false NOT NULL,
  "created_at" timestamp DEFAULT now(),
  "updated_at" timestamp DEFAULT now()
);
```

**Дополнительное хранилище: Память (`memory.ORGANIZATIONS`)**

Память используется для быстрого доступа. Инициализируется в `apps/api/src/data/memory.ts`.

#### Как создается организация

1. **Создание через API** (`POST /api/organizations`):

   ```typescript
   // apps/web/app/api/organizations/route.ts
   const organization = await organizationsRepository.create({
     ownerId: userId,
     name: body.name,
     description: body.description,
     type: body.type === 'open' ? 'open' : 'closed',
     isPublicInDirectory: body.isPublicInDirectory ?? body.type === 'open',
   });
   ```

2. **Процесс создания** (`organizationsRepository.create()`):
   - Создается запись в таблице `organization` через Drizzle
   - Создается запись в таблице `organization_member` (владелец становится участником)
   - Устанавливается `isPrimary = true` для первой организации пользователя
   - Добавляется в память (`memory.ORGANIZATIONS`)

3. **Проверка лимитов**:
   - Проверяется подписка пользователя (`getUserSubscription()`)
   - Проверяется количество организаций (`getOwnedOrganizationsCount()`)
   - Free план: максимум 1 организация
   - Pro/Max план: неограниченно

#### Проблема с текущей организацией

Организация `acct-collabverse` существует **только в памяти**, но не в БД. Это происходит потому что:

- Организация создана при инициализации демо-данных
- Не была синхронизирована с БД при первом запуске
- При перезапуске сервера организация "исчезает"

### 3. Проекты (Projects)

#### Что такое проект

Проект — это контейнер для задач, принадлежащий организации. Проект имеет:

- **ID**: UUID (генерируется через `crypto.randomUUID()`)
- **Owner ID**: ID пользователя-владельца (берется из сессии аутентификации)
- **Organization ID**: ID организации (обязательно для проектов из шаблонов)
- **Workspace ID**: ID рабочего пространства (`ws-collabverse-core`)
- **Key**: уникальный ключ проекта в рамках workspace (например, "TP1", "TP2")
- **Title**: название проекта
- **Visibility**: `private` или `public`

#### Где хранятся данные проекта

**ПРОБЛЕМА: Два пути хранения проектов**

##### Путь 1: Таблица `project` (Drizzle схема)

Создается через миграцию `0001_chemical_lake.sql`:

```sql
CREATE TABLE "project" (
  "id" text PRIMARY KEY NOT NULL,
  "organization_id" text,
  "owner_id" text NOT NULL,
  "name" text NOT NULL,
  "description" text,
  "stage" text,
  "visibility" text,
  "created_at" timestamp DEFAULT now(),
  "updated_at" timestamp DEFAULT now()
);
```

**Статус:** ❌ **НЕ ИСПОЛЬЗУЕТСЯ** - в таблице 0 проектов

##### Путь 2: Таблица `pm_projects` (SQL схема)

Создается динамически через `ensurePmTables()` в `pm-pg-adapter.ts`:

```sql
CREATE TABLE IF NOT EXISTS pm_projects (
  id TEXT PRIMARY KEY,
  workspace_id TEXT NOT NULL,
  key TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  owner_id TEXT NOT NULL,
  status TEXT NOT NULL,
  visibility TEXT NOT NULL,
  budget_planned NUMERIC,
  budget_spent NUMERIC,
  workflow_id TEXT,
  archived BOOLEAN DEFAULT FALSE,
  stage TEXT,
  deadline TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Статус:** ✅ **ИСПОЛЬЗУЕТСЯ** - в таблице 48 проектов

**Память:** `memory.PROJECTS` - **0 проектов** (не загружены)

#### Почему существуют два пути хранения

**Исторические причины:**

1. **Таблица `project` (Drizzle)**:
   - Создана в ранних миграциях для основной схемы БД
   - Предназначена для хранения проектов через Drizzle ORM
   - Имеет связь с `organization` через `organization_id`
   - **НЕ ИСПОЛЬЗУЕТСЯ** в текущей реализации

2. **Таблица `pm_projects` (SQL)**:
   - Создана позже для модуля Project Management (PM)
   - Используется для хранения проектов через прямой SQL
   - Имеет дополнительные поля (`workspace_id`, `key`, `budget_planned`, и т.д.)
   - **ИСПОЛЬЗУЕТСЯ** в текущей реализации

**Причина разрозненности:**

- Проекты создаются через `upsertOrganizationProject()` в `project-template-service.ts`
- Эта функция записывает напрямую в `pm_projects` через SQL
- Таблица `project` устарела и не используется
- Репозитории читают из памяти, поэтому данные из БД не видны

#### Как создается проект

**Процесс создания проекта из шаблона:**

1. **Валидация** (`project-template-service.ts`):

   ```typescript
   // 1. Проверка существования шаблона
   const template = templatesRepository.findById(templateId);

   // 2. Проверка существования организации (ДОБАВЛЕНО В ИСПРАВЛЕНИИ)
   const organization = await organizationsRepository.findById(organizationId);

   // 3. Валидация selectedTaskIds (ДОБАВЛЕНО В ИСПРАВЛЕНИИ)
   // Проверка происходит ДО создания проекта
   ```

2. **Создание проекта в памяти**:

   ```typescript
   // projectsRepository.create() создает проект в памяти
   project = projectsRepository.create({
     title: projectTitle,
     ownerId: params.ownerId, // Из сессии аутентификации
     workspaceId: DEFAULT_WORKSPACE_ID,
     visibility: visibility,
   });
   // ID генерируется: crypto.randomUUID()
   // Key генерируется: generateProjectKey(workspaceId, key, title)
   // OwnerNumber: getNextOwnerProjectNumber(ownerId)
   ```

3. **Запись в БД** (`upsertOrganizationProject()`):

   ```typescript
   // Записывается напрямую в pm_projects через SQL
   await db.insert(projectsTable).values({
     id: project.id,
     organizationId: organizationId,
     ownerId: ownerId,
     name: title,
     // ...
   }).onConflictDoUpdate({ ... });
   ```

4. **Создание задач**:
   ```typescript
   // Задачи создаются из шаблона
   const created = tasksRepository.create({
     projectId: project.id,
     title: task.title,
     status: task.defaultStatus,
     // ...
   });
   // ID задачи: crypto.randomUUID() или input.id
   ```

#### Откуда берется ownerId

**Owner ID берется из сессии аутентификации:**

1. **API Route** (`/api/projects/from-template`):

   ```typescript
   const auth = getAuthFromRequest(request);
   // auth.userId - это ID пользователя из сессии
   ```

2. **Передача в сервис**:

   ```typescript
   await projectTemplateService.createProjectFromTemplate({
     ownerId: auth.userId, // ID из сессии
     organizationId: parsed.data.organizationId,
     // ...
   });
   ```

3. **Использование в репозитории**:
   ```typescript
   projectsRepository.create({
     ownerId: params.ownerId, // Используется для проекта
     // ...
   });
   ```

#### Как присваиваются ID

**Проекты:**

- **ID проекта**: `crypto.randomUUID()` - генерируется в `projectsRepository.create()`
- **Key проекта**: `generateProjectKey(workspaceId, key, title)` - уникальный ключ в рамках workspace
- **Owner Number**: `getNextOwnerProjectNumber(ownerId)` - последовательный номер для владельца

**Задачи:**

- **ID задачи**: `crypto.randomUUID()` или `input.id` (если передан) - генерируется в `tasksRepository.create()`
- **Number задачи**: `getNextTaskNumber(projectId)` - последовательный номер в рамках проекта

**Организации:**

- **ID организации**: Генерируется в `organizationsRepository.create()` через `crypto.randomUUID()` или переданный ID

### 4. Задачи (Tasks)

#### Что такое задача

Задача — это единица работы в проекте. Задача имеет:

- **ID**: UUID (генерируется через `crypto.randomUUID()`)
- **Project ID**: ID проекта, к которому принадлежит задача
- **Number**: последовательный номер в рамках проекта
- **Title**: название задачи
- **Status**: `new`, `in_progress`, `done`, и т.д.
- **Parent ID**: ID родительской задачи (для иерархии)

#### Где хранятся данные задачи

**Основное хранилище: БД (таблица `pm_tasks`)**

Таблица создается динамически через `ensurePmTables()` в `pm-pg-adapter.ts`:

```sql
CREATE TABLE IF NOT EXISTS pm_tasks (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  number INTEGER NOT NULL,
  parent_id TEXT,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT NOT NULL,
  iteration_id TEXT,
  assignee_id TEXT,
  start_at TEXT,
  start_date TEXT,
  due_at TEXT,
  priority TEXT,
  labels JSONB,
  estimated_time INTEGER,
  story_points INTEGER,
  logged_time INTEGER,
  price TEXT,
  currency TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Память:** `memory.TASKS` - **0 задач** (не загружены)

#### Как создается задача

1. **Создание в памяти** (`tasksRepository.create()`):

   ```typescript
   const task: Task = {
     id: input.id ?? crypto.randomUUID(),
     projectId: input.projectId,
     number: input.number ?? this.getNextTaskNumber(input.projectId),
     title: input.title,
     status: input.status,
     // ...
   };
   memory.TASKS.push(task);
   ```

2. **Запись в БД** (`persistTaskToPg()`):

   ```typescript
   // Асинхронно записывается в pm_tasks
   if (isPmDbEnabled()) {
     void persistTaskToPg(task).catch((error) =>
       console.error('[TasksRepository] Failed to persist task', error)
     );
   }
   ```

3. **При создании из шаблона**:
   ```typescript
   // В project-template-service.ts
   const created = tasksRepository.create({
     projectId: project.id,
     title: task.title,
     status: task.defaultStatus,
     // ...
   });
   ```

## Резюме

Аудит данных показал следующее распределение:

| Тип данных      | Всего найдено | Только в БД | Только в памяти | В БД и памяти |
| --------------- | ------------- | ----------- | --------------- | ------------- |
| **Организации** | 1             | 0           | 1               | 0             |
| **Проекты**     | 48            | 48          | 0               | 0             |
| **Задачи**      | 38            | 38          | 0               | 0             |
| **ИТОГО**       | **87**        | **86**      | **1**           | **0**         |

## Детальный анализ

### 1. Организации

#### Найдено: 1 организация

| ID                 | Название             | Расположение        | Таблица БД | Ключ памяти            | Источник | Как попало                          |
| ------------------ | -------------------- | ------------------- | ---------- | ---------------------- | -------- | ----------------------------------- |
| `acct-collabverse` | Collabverse Demo Org | **Только в памяти** | N/A        | `memory.ORGANIZATIONS` | Memory   | Инициализация при старте приложения |

**Проблема:** Организация существует только в памяти, но не в БД. Это может быть причиной того, что организация "исчезает" при перезапуске сервера.

**Пути хранения:**

- ✅ Память: `memory.ORGANIZATIONS[0]`
- ❌ БД (Drizzle): таблица `organization` - **НЕ НАЙДЕНО**
- ❌ БД (SQL): таблица `organization` - **НЕ НАЙДЕНО**
- ✅ Репозиторий: `organizationsRepository.listForUser()` - **НАЙДЕНО**

### 2. Проекты

#### Найдено: 48 проектов

**Расположение:** Все проекты находятся **только в БД** (таблица `pm_projects`)

**Пути хранения:**

- ✅ БД (SQL): таблица `pm_projects` - **48 проектов**
- ❌ БД (Drizzle): таблица `project` - **0 проектов** (таблица устарела)
- ❌ Память: `memory.PROJECTS` - **0 проектов** (память пуста, репозитории читают ее)
- ❌ Репозиторий: `projectsRepository.list()` - **0 проектов** (работает с памятью)

**Как попало в БД:**

- Проекты создаются через `upsertOrganizationProject()` в `project-template-service.ts`
- Записываются напрямую в таблицу `pm_projects` через SQL
- Таблица `project` устарела и не используется
- Репозитории читают память, поэтому данные из БД не видны

**Примеры проектов:**

- `Бренд-пакет` (319c987a-155f-4064-acf0-912211e812cd) - создан из шаблона
- 47 проектов `Test Project` - тестовые проекты, созданные при разработке

### 3. Задачи

#### Найдено: 38 задач

**Расположение:** Все задачи находятся **только в БД** (таблица `pm_tasks`)

**Пути хранения:**

- ✅ БД (SQL): таблица `pm_tasks` - **38 задач**
- ❌ Память: `memory.TASKS` - **0 задач** (память пуста, репозитории читают ее)
- ❌ Репозиторий: `tasksRepository.list()` - **0 задач** (работает с памятью)

**Как попало в БД:**

- Задачи создаются через `tasksRepository.create()`
- Записываются в БД через `persistTaskToPg()` в `pm-pg-adapter.ts`
- Репозитории читают память, поэтому данные из БД не видны

**Типы задач:**

- 16 задач из шаблона "Бренд-пакет" (исследование, разработка логотипа, документация и т.д.)
- 22 задачи "Test Task" - тестовые задачи

## Проблемы и несоответствия

### Критические проблемы

1. **Организация только в памяти**
   - Организация `acct-collabverse` существует только в памяти
   - При перезапуске сервера организация "исчезает"
   - Нужно сохранить в БД

2. **Репозитории проектов читают из памяти**
   - 48 проектов в БД (`pm_projects`), но 0 в памяти
   - Репозиторий `projectsRepository.list()` возвращает пустой список
   - Нужно перевести чтение/запись репозиториев на БД

3. **Репозитории задач читают из памяти**
   - 38 задач в БД (`pm_tasks`), но 0 в памяти
   - Репозиторий `tasksRepository.list()` возвращает пустой список
   - Нужно перевести чтение/запись репозиториев на БД

### Архитектурные несоответствия

1. **Два пути хранения проектов:**
   - Drizzle схема `project` (таблица `project`) - **не используется**
   - Прямой SQL `pm_projects` - **используется**
   - Решение: `pm_projects`/`pm_tasks` — канон, `project` выводится из эксплуатации

2. **Память используется как источник данных:**
   - Данные создаются в БД, но не загружаются в память
   - Репозитории работают с памятью, но память пуста
   - Решение: репозитории читают/пишут в БД, память — только кэш

## Как делают крупные платформы (проверенные практики)

Ниже — подходы, которые реально работают на больших платформах с большим количеством пользователей и сущностей. Это не «теория», а стандартные архитектурные решения для масштаба.

### 1. Единый источник истины (Single Source of Truth)

- Канонический источник — **БД**, не память.
- In-memory слой — только кэш, его можно очистить без потери данных.
- Нет двух таблиц для одной сущности.

### 2. Жесткая модель связей и tenant-ключей

- Все данные «следуют за пользователем» через `organization_id`/`workspace_id`.
- У проектов и задач обязательны связи: `organization_id`, `owner_id`, `project_id`.
- Индексы по tenant-ключам обязательны, иначе масштабирование ломается.

### 3. Транзакционный write-path

- Создание проекта и задач — **в одной транзакции**.
- Если часть действий асинхронная — использовать **outbox + очередь**, а не «записать в память и потом».

### 4. Кэш — это ускоритель, не хранилище

- Read-through/write-through или cache-aside.
- Кэш инвалидация по событиям, а не «вечная память».
- Полная гидратация памяти допустима только для маленьких справочников.

### 5. События вместо дублирования

- Отдельные модули получают события (`ProjectCreated`, `TaskCreated`).
- Это позволяет избежать параллельных таблиц и разъезда данных.

## Рекомендованный целевой сценарий (как должно быть реализовано)

### Единый поток создания данных

```
POST /api/projects
1) auth -> userId
2) authorize(userId, organizationId)
3) DB transaction:
   - insert pm_projects (organization_id, owner_id, workspace_id, key, title, ...)
   - insert pm_tasks (project_id, ...)
4) commit
5) publish ProjectCreated (optional)
6) invalidate cache (optional)
```

### Единая модель сущностей (пользователь и все связанное)

- `users` — только персональные данные пользователя.
- `organization_members` — связь user ↔ organization.
- `organizations` — контейнер доступа.
- `projects` — принадлежат organization (owner_id обязателен).
- `tasks` — принадлежат project.

Такой путь гарантирует, что **все, что «следует за пользователем», всегда имеет organization_id** и масштабируется линейно.

### Единая таблица проектов

- Должна остаться **одна** таблица проектов: `pm_projects` (решение зафиксировано).
- Репозитории читают/пишут в БД, а не в `memory.*`.
- Если нужен ORM — описать `pm_projects`/`pm_tasks` в Drizzle и отказаться от прямого SQL.

### Роль памяти

- Память может хранить только справочники/кэши с TTL.
- Никаких «основных данных» в `memory.*`.

### Стратегия кэша (рекомендации для платформы)

- **Базовый паттерн:** cache-aside (чтение из кэша, промах → БД → запись в кэш).
- **Что кэшировать:** справочники, настройки, роли, тарифы, редко меняющиеся данные.
- **Что не кэшировать полностью:** проекты, задачи, активность — только выборки с TTL.
- **TTL и инвалидация:** TTL 1–10 минут + инвалидация по событиям записи.
- **Ключи:** обязательно включать `organization_id`/`workspace_id` в ключ.
- **Прогрев:** допускается только для маленьких справочников, не для рабочих данных.

## Рекомендации

### Немедленные действия

1. **Синхронизировать организацию с БД:**

   ```typescript
   // Создать организацию в БД через Drizzle
   await db.insert(organizations).values({
     id: 'acct-collabverse',
     name: 'Collabverse Demo Org',
     ownerId: '00000000-0000-0000-0000-000000000001',
     // ... другие поля
   });
   ```

2. **Зафиксировать каноническое хранилище проектов:**
   - Оставляем `pm_projects` и `pm_tasks` как единственные таблицы.
   - Убираем использование Drizzle-таблицы `project` как источника данных.

3. **Сделать транзакционный create-path:**
   - Создание проекта и задач — в одной транзакции.
   - Если есть асинхронные шаги — через outbox + очередь.

### Долгосрочные улучшения

1. **Унифицировать хранение проектов и задач:**
   - Канонические таблицы: `pm_projects` и `pm_tasks`.
   - Описать `pm_projects`/`pm_tasks` в Drizzle (если нужен ORM), убрать дублирование схем.

2. **Описать стратегию кэша:**
   - In-memory только как кэш с TTL/инвалидацией.
   - Без полной «гидратации» рабочей базы при старте.

3. **Документировать архитектуру хранения и доступов:**
   - Где какие данные хранятся
   - Как происходит кэширование и инвалидация
   - Когда использовать память, когда БД

## Таблица путей хранения (обновлено 2026-01-05)

| Тип данных       | БД (Drizzle)       | БД (SQL)           | Память                       | Репозиторий                   | Статус              |
| ---------------- | ------------------ | ------------------ | ---------------------------- | ----------------------------- | ------------------- |
| **Пользователи** | `user` (1)         | `user` (1)         | `memory.WORKSPACE_USERS` (1) | `usersRepository` (1)         | ✅ Синхронизировано |
| **Организации**  | `organization` (1) | `organization` (1) | `memory.ORGANIZATIONS` (1)   | `organizationsRepository` (1) | ✅ Синхронизировано |
| **Проекты**      | `project` (0)      | `pm_projects` (48) | `memory.PROJECTS` (кэш)      | `projectsRepository` (48)     | ✅ Читает из БД     |
| **Задачи**       | N/A                | `pm_tasks` (38)    | `memory.TASKS` (кэш)         | `tasksRepository` (38)        | ✅ Читает из БД     |

**Легенда:**

- ✅ Работает корректно
- ⚠️ Есть проблемы консистентности
- ❌ Не используется/не найдено

**Примечание:** Таблица `project` (Drizzle) помечена как deprecated, используется только `pm_projects`.

## Причины разрозненного хранения данных

### Исторические причины

1. **Эволюция архитектуры:**
   - Изначально использовалась таблица `project` (Drizzle)
   - Позже добавлен модуль PM с таблицей `pm_projects` (SQL)
   - Обе таблицы существуют параллельно, но используются разные

2. **Разные системы хранения:**
   - **Drizzle схемы** (`project`, `organization`) - для основной схемы БД
   - **SQL таблицы** (`pm_projects`, `pm_tasks`) - для модуля Project Management
   - Нет единого канонического слоя хранения

3. **Память как кэш:**
   - Память (`memory.*`) используется для быстрого доступа
   - Но она используется как источник истины, что неверно
   - Данные должны читаться из БД, а память быть вторичным слоем

### Технические причины

1. **Разные репозитории:**
   - `projectsRepository.create()` - создает в памяти, затем асинхронно в БД
   - `upsertOrganizationProject()` - создает напрямую в БД (`pm_projects`)
   - Нет единого пути создания проектов

2. **Асинхронная запись:**
   - Запись в БД происходит асинхронно (`void persistTaskToPg()`)
   - Если сервер перезапускается до записи, данные теряются
   - Запись должна быть транзакционной в БД, без зависимости от памяти

3. **Зависимость от памяти как источника:**
   - Репозитории работают с `memory.*`, но память пуста
   - Это приводит к пустым спискам при чтении
   - Нужен перенос read/write в БД

## Выводы (обновлено 2026-01-05)

1. **Пользователи синхронизированы** ✅ - данные в БД и памяти совпадают
2. **Репозитории читают из БД** ✅ - проекты и задачи читаются из `pm_projects`/`pm_tasks`
3. **Организация синхронизирована** ✅ - автоматически создается в БД при первом обращении
4. **Канонические таблицы зафиксированы** ✅ - `pm_projects`/`pm_tasks` как единственный источник истины
5. **Память используется как кэш** ✅ - cache-aside паттерн реализован для чтения
6. **Документация обновлена** ✅ - созданы руководства и ADR

### Оставшиеся улучшения

- Унификация точек записи (убрать прямые SQL-вставки)
- Полная реализация cache-aside с TTL и инвалидацией

## Следующие шаги

1. Создать организацию в БД через Drizzle
2. Зафиксировать `pm_projects`/`pm_tasks` как канонические
3. Перевести репозитории на чтение/запись в БД
4. При необходимости добавить кэш с TTL и инвалидацией

## Связанные документы

- **[Анализ связи организаций и проектов](./ORGANIZATION_PROJECT_RELATIONSHIP_ANALYSIS.md)** - детальный анализ проблемы связи проектов с организациями и рекомендации по исправлению

## Полная таблица данных

| Тип              | ID                                     | Название                  | Расположение | Таблица БД    | Ключ памяти              | Источник      | Как попало                                     |
| ---------------- | -------------------------------------- | ------------------------- | ------------ | ------------- | ------------------------ | ------------- | ---------------------------------------------- |
| **Пользователь** | `00000000-0000-0000-0000-000000000001` | Алина Админ               | БД + Память  | `user`        | `memory.WORKSPACE_USERS` | Drizzle + SQL | Регистрация/инициализация                      |
| **Организация**  | `acct-collabverse`                     | Collabverse Demo Org      | Память       | N/A           | `memory.ORGANIZATIONS`   | Memory        | Инициализация демо-данных                      |
| **Проект**       | `319c987a-...`                         | Бренд-пакет               | БД           | `pm_projects` | N/A                      | Direct SQL    | Из шаблона через `upsertOrganizationProject()` |
| **Проект**       | `b0abeeae-...`                         | Test Project              | БД           | `pm_projects` | N/A                      | Direct SQL    | Тестовое создание                              |
| ...              | ...                                    | ... (46 проектов)         | БД           | `pm_projects` | N/A                      | Direct SQL    | Тестовое создание                              |
| **Задача**       | `9ab10a5f-...`                         | Исследование рынка...     | БД           | `pm_tasks`    | N/A                      | Direct SQL    | Из шаблона через `tasksRepository.create()`    |
| **Задача**       | `873e2e8b-...`                         | Разработка иконографии... | БД           | `pm_tasks`    | N/A                      | Direct SQL    | Из шаблона через `tasksRepository.create()`    |
| ...              | ...                                    | ... (36 задач)            | БД           | `pm_tasks`    | N/A                      | Direct SQL    | Из шаблона/тестовые                            |

## Архитектурная схема

```
ПОЛЬЗОВАТЕЛЬ
├── БД: таблица `user` (Drizzle) ✅
├── Память: `memory.WORKSPACE_USERS` ✅
└── Репозиторий: `usersRepository` ✅
    └── Синхронизация: ✅ Работает

ОРГАНИЗАЦИЯ
├── БД: таблица `organization` (Drizzle) ❌ НЕТ ДАННЫХ
├── Память: `memory.ORGANIZATIONS` ✅
└── Репозиторий: `organizationsRepository` ✅
    └── Источник истины: ⚠️ Только память

ПРОЕКТ
├── БД: таблица `project` (Drizzle) ❌ НЕ ИСПОЛЬЗУЕТСЯ
├── БД: таблица `pm_projects` (SQL) ✅ ИСПОЛЬЗУЕТСЯ
├── Память: `memory.PROJECTS` ❌ ПУСТО
└── Репозиторий: `projectsRepository` ⚠️ Работает с памятью (пусто)
    └── Требование: читать/писать в БД

ЗАДАЧА
├── БД: таблица `pm_tasks` (SQL) ✅ ИСПОЛЬЗУЕТСЯ
├── Память: `memory.TASKS` ❌ ПУСТО
└── Репозиторий: `tasksRepository` ⚠️ Работает с памятью (пусто)
    └── Требование: читать/писать в БД
```

## Процесс создания данных

### Создание организации

```
1. POST /api/organizations
   ↓
2. organizationsRepository.create()
   ↓
3. db.insert(organizations).values({ ... })  ← Drizzle
   ↓
4. db.insert(organizationMembers).values({ ... })  ← Drizzle
   ↓
5. memory.ORGANIZATIONS.push(org)  ← Память
```

**Проблема:** Текущая организация создана только в памяти, не в БД

### Создание проекта из шаблона

```
1. POST /api/projects/from-template
   ↓
2. Валидация организации (ДОБАВЛЕНО)
   ↓
3. Валидация selectedTaskIds (ДОБАВЛЕНО)
   ↓
4. projectsRepository.create()
   ├── Генерация ID: crypto.randomUUID()
   ├── Генерация Key: generateProjectKey()
   ├── Owner Number: getNextOwnerProjectNumber()
   └── memory.PROJECTS.push(project)  ← Память
   ↓
5. upsertOrganizationProject()
   └── db.insert(pm_projects).values({ ... })  ← SQL (pm_projects)
   ↓
6. tasksRepository.create() для каждой задачи
   ├── Генерация ID: crypto.randomUUID()
   ├── Number: getNextTaskNumber()
   ├── memory.TASKS.push(task)  ← Память
   └── persistTaskToPg(task)  ← SQL (pm_tasks) - асинхронно
```

**Проблема:** Таблица `project` устарела; запись должна идти только в `pm_projects`/`pm_tasks`

## Рекомендации по исправлению

### Немедленные действия

1. **Синхронизировать организацию с БД:**

   ```typescript
   await db.insert(organizations).values({
     id: 'acct-collabverse',
     name: 'Collabverse Demo Org',
     ownerId: '00000000-0000-0000-0000-000000000001',
     type: 'closed',
     isPublicInDirectory: false,
   });
   ```

2. **Унифицировать хранение проектов и задач:**
   - Канонические таблицы: `pm_projects` и `pm_tasks`
   - Мигрировать данные из `project`, если они появятся
   - Обновить код создания проектов для использования единого пути

### Долгосрочные улучшения

1. **Единая точка создания проектов:**
   - Использовать только `projectsRepository.create()`
   - Убрать `upsertOrganizationProject()` или сделать его оберткой над репозиторием

2. **Стратегия кэша:**
   - Память — только кэш (TTL/инвалидация)
   - Без полной гидратации рабочей базы при старте

3. **Документировать архитектуру:**
   - Где какие данные хранятся
   - Как происходит кэширование и инвалидация
   - Когда использовать память, когда БД

## Зафиксированное решение по проектам

- Канонические таблицы: `pm_projects` и `pm_tasks`.
- Таблица `project` (Drizzle) не используется как источник истины и подлежит выводу из эксплуатации.

## Четкий план устранения разрозненности (инструкции)

### 1. Устранить дублирование таблиц

1. Зафиксировать `pm_projects`/`pm_tasks` как единственный источник истины.
2. Пометить `project` как устаревшую (deprecated) и запретить запись в нее.
3. Если `project` все еще используется где-то в коде — мигрировать чтения/записи на `pm_projects`.

### 2. Обеспечить единую точку записи

1. Все create/update операции для проектов и задач должны проходить через единый сервис/репозиторий.
2. Запись «проект + задачи» — в одной транзакции.
3. Асинхронные шаги выносить через outbox + очередь (без сохранения в память как источника данных).

### 3. Свести кэш к вторичному слою

1. `memory.*` не хранит каноничные данные.
2. Любой кэш — только с TTL и инвалидацией.
3. Запись всегда идет в БД, кэш обновляется после.

### 4. Поддержка целостности

1. Все сущности, «следующие за пользователем», обязаны иметь `organization_id` или `workspace_id`.
2. Индексы по `organization_id`/`workspace_id` обязательны.
3. Проверки доступа всегда происходят по tenant-ключам.

### 5. Контроль качества данных

1. Ввести проверку «таблица → репозиторий» (каждая таблица должна иметь единый путь записи/чтения).
2. Запретить прямой SQL вне выделенного слоя доступа.
3. Добавить метрики/логи о расхождениях (например, если данные есть в БД, но их нет в кэше).

## Задания для следующего агента (расширенный аудит)

Следующий агент должен выполнить задачи выше **и дополнительно провести аудит остальных разделов**, чтобы выявить новые зоны разрозненности.

### Обязательные шаги аудита

1. Составить перечень всех таблиц БД и сопоставить их с репозиториями/сервисами.
2. Найти дублирующиеся или «параллельные» пути записи для одних сущностей.
3. Проверить, где используются in-memory структуры как источник истины.
4. Выявить таблицы без проверок доступа (tenant-ключей) и без индексов по ним.
5. Зафиксировать список несоответствий и предложить план устранения.

### Что должно быть в результате

- Обновленный отчет с перечислением всех зон хранения данных.
- Список проблем и причин разрозненности по каждому разделу.
- Рекомендации, какие таблицы считать каноническими и как мигрировать данные.
