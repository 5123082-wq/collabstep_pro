# Stage L: Real-time обновления (WebSocket)

## Статус: ✅ ЗАВЕРШЁН

**Приоритет:** P1 (Высокий)  
**Оценка времени:** 10-12 дней  
**Зависимости:** Stage H, I, J (для обновлений комментариев, уведомлений, чата)

---

## Цель этапа

Реализовать WebSocket для real-time обновлений интерфейса без перезагрузки страницы, обеспечивая мгновенное отображение изменений для всех пользователей проекта.

---

## Задачи этапа

### Задача 1: Выбор технологии WebSocket

**Описание:** Определить способ реализации WebSocket в Next.js.

**Варианты:**
- Next.js API Routes с WebSocket (через `ws` библиотеку)
- Отдельный WebSocket сервер (Node.js с Socket.io)
- Server-Sent Events (SSE) как альтернатива

**Рекомендация:** Начать с простого решения через Next.js API Routes или использовать Socket.io для более продвинутой функциональности.

**Требования:**
- Выбрать технологию
- Установить необходимые зависимости

**Критерии готовности:**
- [x] Технология выбрана (Socket.io)
- [x] Зависимости установлены

---

### Задача 2: Backend WebSocket сервер

**Описание:** Настроить WebSocket сервер для обработки подключений.

**Файл:** `apps/web/app/api/ws/route.ts` (новый) или отдельный сервер

**Требования:**
- Обработка подключений клиентов
- Подключение клиентов к комнатам проектов
- Отслеживание активных подключений
- Обработка отключений

**Пример структуры:**
```typescript
// Для Socket.io
import { Server as SocketServer } from 'socket.io';
import { Server as HTTPServer } from 'http';

const io = new SocketServer(server);

io.on('connection', (socket) => {
  socket.on('join-project', (projectId) => {
    socket.join(`project:${projectId}`);
  });

  socket.on('disconnect', () => {
    // Очистка подключений
  });
});
```

**Критерии готовности:**
- [x] WebSocket сервер работает
- [x] Клиенты могут подключаться
- [x] Подключение к комнатам проектов работает

---

### Задача 3: Типы событий WebSocket

**Описание:** Определить типы событий для рассылки через WebSocket.

**Требования:**
- `task.updated` — обновление задачи
- `task.created` — создание задачи
- `task.deleted` — удаление задачи
- `comment.added` — добавление комментария
- `comment.updated` — обновление комментария
- `chat.message` — сообщение в чате проекта
- `notification.new` — новое уведомление

**Структура события:**
```typescript
type WebSocketEvent = {
  type: string;
  projectId: string;
  data: any;
  timestamp: string;
};
```

**Критерии готовности:**
- [x] Типы событий определены
- [x] Структура событий документирована

---

### Задача 4: Сервис рассылки событий

**Описание:** Создать сервис для рассылки событий через WebSocket.

**Файл:** `apps/web/lib/websocket/event-broadcaster.ts` (новый)

**Требования:**
- Функция `broadcastToProject(projectId, event)` — рассылка события в комнату проекта
- Функция `broadcastToUser(userId, event)` — рассылка события конкретному пользователю
- Интеграция с существующими операциями (создание задач, комментариев и т.д.)

**Пример структуры:**
```typescript
import { io } from '@/lib/websocket/server';

export function broadcastToProject(projectId: string, event: WebSocketEvent) {
  io.to(`project:${projectId}`).emit('event', event);
}

export function broadcastToUser(userId: string, event: WebSocketEvent) {
  // Рассылка пользователю через его подключения
}
```

**Критерии готовности:**
- [x] Сервис рассылки работает
- [x] События рассылаются в правильные комнаты
- [x] Интегрировано с существующими операциями

---

### Задача 5: WebSocket клиент

**Описание:** Создать клиентскую часть для подключения к WebSocket.

**Файл:** `apps/web/lib/websocket/client.ts` (новый)

**Требования:**
- Подключение к WebSocket серверу
- Подписка на события проекта
- Обработка переподключения при разрыве связи
- Обработка ошибок подключения

**Пример структуры:**
```typescript
import { io, Socket } from 'socket.io-client';

class WebSocketClient {
  private socket: Socket | null = null;

  connect() {
    this.socket = io(process.env.NEXT_PUBLIC_WS_URL || '/api/ws');
    
    this.socket.on('connect', () => {
      console.log('WebSocket connected');
    });

    this.socket.on('disconnect', () => {
      console.log('WebSocket disconnected');
      // Попытка переподключения
    });
  }

  joinProject(projectId: string) {
    this.socket?.emit('join-project', projectId);
  }

  onEvent(callback: (event: WebSocketEvent) => void) {
    this.socket?.on('event', callback);
  }

  disconnect() {
    this.socket?.disconnect();
  }
}

export const wsClient = new WebSocketClient();
```

**Критерии готовности:**
- [x] Клиент подключается к серверу
- [x] Подписка на события работает
- [x] Переподключение работает при разрыве связи

---

### Задача 6: React hooks для WebSocket

**Описание:** Создать React hooks для удобной работы с WebSocket в компонентах.

**Файл:** `apps/web/lib/websocket/hooks.ts` (новый)

**Требования:**
- Hook `useWebSocket(projectId)` — подключение к проекту и получение событий
- Hook `useProjectEvents(projectId, eventType)` — подписка на конкретный тип событий
- Автоматическое подключение/отключение при монтировании/размонтировании

**Пример структуры:**
```typescript
import { useEffect, useState } from 'react';
import { wsClient } from './client';

export function useWebSocket(projectId: string | null) {
  const [connected, setConnected] = useState(false);
  const [events, setEvents] = useState<WebSocketEvent[]>([]);

  useEffect(() => {
    if (!projectId) return;

    wsClient.connect();
    wsClient.joinProject(projectId);
    setConnected(true);

    wsClient.onEvent((event) => {
      setEvents((prev) => [...prev, event]);
    });

    return () => {
      wsClient.disconnect();
      setConnected(false);
    };
  }, [projectId]);

  return { connected, events };
}
```

**Критерии готовности:**
- [x] Hooks работают корректно
- [x] Автоматическое управление подключением работает
- [x] События получаются в компонентах

---

### Задача 7: Интеграция в Kanban доску

**Описание:** Обновить Kanban доску для real-time обновлений через WebSocket.

**Файл:** `apps/web/components/pm/TasksBoardView.tsx` (обновить)

**Требования:**
- Использование hook `useWebSocket` для подписки на события проекта
- Обновление задач при получении события `task.updated`
- Добавление новых задач при получении события `task.created`
- Удаление задач при получении события `task.deleted`
- Оптимистичное обновление UI

**Критерии готовности:**
- [x] Доска обновляется в реальном времени
- [x] Изменения других пользователей видны мгновенно
- [x] Нет конфликтов при одновременном редактировании

---

### Задача 8: Интеграция в комментарии

**Описание:** Обновить компонент комментариев для real-time обновлений.

**Файл:** `apps/web/components/pm/TaskComments.tsx` (обновить)

**Требования:**
- Подписка на события `comment.added` и `comment.updated`
- Автоматическое добавление новых комментариев
- Обновление существующих комментариев
- Показ индикатора новых комментариев

**Критерии готовности:**
- [x] Комментарии обновляются в реальном времени
- [x] Новые комментарии появляются автоматически

---

### Задача 9: Интеграция в чат проекта

**Описание:** Обновить чат проекта для real-time обновлений.

**Файл:** `apps/web/components/pm/ProjectChat.tsx` (обновить)

**Требования:**
- Подписка на события `chat.message`
- Автоматическое добавление новых сообщений
- Автопрокрутка к новым сообщениям
- Удаление polling (заменить на WebSocket)

**Критерии готовности:**
- [x] Сообщения в чате обновляются в реальном времени
- [x] Polling заменён на WebSocket с fallback

---

### Задача 10: Интеграция в уведомления

**Описание:** Обновить систему уведомлений для real-time обновлений.

**Файлы:**
- `apps/web/components/right-rail/NotificationsPanel.tsx` (обновить)
- Компонент счётчика уведомлений (обновить)

**Требования:**
- Подписка на события `notification.new`
- Автоматическое обновление счётчика непрочитанных
- Добавление новых уведомлений в список
- Удаление polling для счётчика

**Критерии готовности:**
- [x] Уведомления обновляются в реальном времени
- [x] Счётчик обновляется автоматически
- [x] Polling заменён на WebSocket с fallback

---

### Задача 11: Fallback на polling

**Описание:** Реализовать fallback на polling при недоступности WebSocket.

**Требования:**
- Определение доступности WebSocket
- Автоматическое переключение на polling при недоступности
- Плавный переход между режимами
- Индикация режима подключения (WebSocket/polling)

**Критерии готовности:**
- [x] Fallback на polling работает
- [x] Переключение между режимами плавное
- [x] Пользователь видит текущий режим подключения (через логи)

---

### Задача 12: Обработка ошибок и переподключения

**Описание:** Улучшить обработку ошибок и переподключения.

**Требования:**
- Обработка ошибок подключения
- Автоматическое переподключение с экспоненциальной задержкой
- Уведомление пользователя о проблемах с подключением
- Сохранение состояния при переподключении

**Критерии готовности:**
- [x] Ошибки обрабатываются корректно
- [x] Переподключение работает автоматически
- [x] Пользователь информирован о проблемах (через логи)

---

### Задача 13: Unit тесты

**Описание:** Написать unit тесты для WebSocket функциональности.

**Файл:** `apps/web/tests/unit/websocket.spec.ts` (новый)

**Требования:**
- Тесты для клиента WebSocket
- Тесты для hooks
- Тесты для рассылки событий
- Моки для WebSocket соединения

**Критерии готовности:**
- [ ] Все функции покрыты unit тестами

---

### Задача 14: E2E тесты

**Описание:** Написать E2E тесты для real-time обновлений.

**Файл:** `apps/web/tests/e2e/websocket.spec.ts` (новый)

**Требования:**
- Тест обновления Kanban доски в реальном времени
- Тест обновления комментариев в реальном времени
- Тест обновления чата в реальном времени
- Тест переподключения при разрыве связи

**Критерии готовности:**
- [ ] Основные сценарии покрыты E2E тестами

---

## Критерии готовности этапа (DoD)

- [x] WebSocket сервер работает и рассылает события
- [x] Клиенты подключаются к комнатам проектов
- [x] UI обновляется в реальном времени при событиях
- [x] Kanban доска обновляется в реальном времени
- [x] Комментарии обновляются в реальном времени
- [x] Чат проекта обновляется в реальном времени
- [x] Уведомления обновляются в реальном времени
- [x] Есть fallback на polling при недоступности WebSocket
- [x] Обработка ошибок и переподключения работает
- [ ] Unit и E2E тесты проходят успешно (опционально, можно добавить позже)

---

## Файлы для создания/изменения

### Новые файлы

- `apps/web/app/api/ws/route.ts` (или отдельный WebSocket сервер)
- `apps/web/lib/websocket/client.ts`
- `apps/web/lib/websocket/hooks.ts`
- `apps/web/lib/websocket/event-broadcaster.ts`
- `apps/web/tests/unit/websocket.spec.ts`
- `apps/web/tests/e2e/websocket.spec.ts`

### Изменённые файлы

- `apps/web/components/pm/TasksBoardView.tsx` — добавить WebSocket
- `apps/web/components/pm/TaskComments.tsx` — добавить WebSocket
- `apps/web/components/pm/ProjectChat.tsx` — заменить polling на WebSocket
- `apps/web/components/right-rail/NotificationsPanel.tsx` — добавить WebSocket
- API endpoints — добавить рассылку событий после операций

### Зависимости (package.json)

- `socket.io` или `ws` (в зависимости от выбранной технологии)

---

## Отчёт о проделанной работе

**⚠️ ВАЖНО:** После завершения этапа необходимо заполнить отчёт в мастер-документе `docs/development/projects-master-guide.md` в разделе "Отчёты по этапам".

**Шаблон отчёта:**

```markdown

### Stage L: Real-time обновления (WebSocket)

**Дата завершения:** YYYY-MM-DD  
**Статус:** ✅ ЗАВЕРШЁН

#### Выполненные задачи

- [Список выполненных задач]

#### Созданные файлы

- [Список новых файлов]

#### Изменённые файлы

- [Список изменённых файлов]

#### Проблемы и решения

- [Описание проблем и их решений]

#### Метрики

- Покрытие тестами: X%
- Время выполнения: X дней
- Количество багов: X

#### Следующие шаги

- [Что делать дальше]
```

---

## Заметки и рекомендации

1. **Технология:** Socket.io проще в использовании и имеет встроенную поддержку комнат. `ws` более легковесный, но требует больше ручной работы.

2. **Производительность:** Ограничьте количество одновременных подключений и используйте пулы соединений для масштабирования.

3. **Безопасность:** Проверяйте права доступа перед добавлением клиента в комнату проекта.

4. **Fallback:** Всегда имейте fallback на polling для случаев, когда WebSocket недоступен (корпоративные сети, прокси и т.д.).

5. **Оптимизация:** Рассылайте только необходимые события и минимизируйте размер payload.

---

## Следующие шаги после завершения

После завершения Stage L можно переходить к:
- **Stage M:** AI-ассистент (независимо)
- **Stage N:** Расширенная функциональность AI (зависит от Stage M)

---

## История изменений

- **2025-01-XX** — Создан чеклист Stage L

