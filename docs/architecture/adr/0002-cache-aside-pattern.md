# ADR-0002: Cache-aside паттерн для чтения данных

**Статус:** Принято  
**Дата:** 2026-01-07  
**Владелец:** engineering  
**Авторы:** Architecture Documentation  
**Последнее обновление:** 2026-01-07

## Контекст

В системе существовала проблема с хранением данных: репозитории читали данные из памяти, которая была пуста при перезапуске сервера. Это приводило к тому, что данные "исчезали" после перезапуска, так как они существовали только в памяти.

Также возникла необходимость оптимизировать чтение данных из БД, так как частые запросы к PostgreSQL могут создавать нагрузку на базу данных.

## Решение

**Использовать cache-aside паттерн для чтения данных: память используется только как кэш, БД — единственный источник истины.**

### Детали решения

1. **Принцип "БД как единственный источник истины":**
   - Все данные хранятся в PostgreSQL (Vercel Postgres)
   - Память используется только как кэш для оптимизации чтения
   - При записи: запись в БД → инвалидация/обновление кэша

2. **Cache-aside паттерн для чтения:**
   ```text
   1. Проверка кэша (память)
   2. Если промах → чтение из БД
   3. Запись в кэш для последующих запросов
   ```

3. **Реализация в репозиториях:**
   - `ProjectsRepository.list()` — проверяет кэш, при промахе читает из `pm_projects`
   - `TasksRepository.list()` — проверяет кэш, при промахе читает из `pm_tasks`
   - `OrganizationsRepository.findById()` — проверяет кэш, при промахе читает из БД

4. **Fallback на память:**
   - Если БД недоступна, репозитории используют память как fallback
   - Это позволяет системе работать даже при проблемах с БД (dev режим)

### Пример реализации

```typescript
async list(options: { workspaceId?: string }): Promise<Project[]> {
  if (isPmDbEnabled()) {
    // Формируем ключ кэша
    const workspaceId = options.workspaceId?.trim();
    const cacheKey = workspaceId ? `projects:workspace:${workspaceId}` : 'projects:all';
    
    // Проверяем кэш
    const cached = cacheManager.getProjects(cacheKey);
    if (cached) {
      return cached.map(cloneProject);
    }

    // Кэш промах - читаем из БД
    const dbProjects = await fetchProjectsFromPg(options);
    
    // Сохраняем в кэш
    cacheManager.setProjects(cacheKey, dbProjects);
    
    return dbProjects.map(cloneProject);
  }
  
  // Fallback на память
  return memory.PROJECTS.map(cloneProject);
}
```

## Последствия

### Положительные

- ✅ **Производительность:** Кэширование результатов запросов уменьшает нагрузку на БД
- ✅ **Надежность:** Данные не теряются при перезапуске сервера (хранятся в БД)
- ✅ **Масштабируемость:** Можно масштабировать кэш отдельно от БД
- ✅ **Гибкость:** Fallback на память позволяет системе работать при проблемах с БД

### Отрицательные

- ⚠️ **Сложность инвалидации:** Нужно инвалидировать кэш при записи данных
- ⚠️ **Консистентность:** Возможны расхождения между кэшем и БД при ошибках записи
- ⚠️ **Память:** Кэш занимает память сервера (ограничено для serverless функций)

### Митигация

- **Инвалидация кэша:** При записи данных кэш инвалидируется или обновляется
- **TTL для кэша:** Кэш имеет время жизни (TTL) для автоматической инвалидации
- **Fallback на БД:** При проблемах с кэшем всегда можно прочитать из БД
- **Мониторинг:** Логирование операций кэша для диагностики проблем

## Альтернативы

### Альтернатива 1: Write-through паттерн

**Рассмотрено:** Запись в кэш и БД одновременно.

**Отклонено:** Сложнее реализация, требует синхронизации записи в два места. Cache-aside проще и эффективнее для read-heavy workloads.

### Альтернатива 2: Write-behind паттерн

**Рассмотрено:** Запись в кэш немедленно, запись в БД асинхронно.

**Отклонено:** Риск потери данных при сбое сервера до записи в БД. Не подходит для критических данных.

### Альтернатива 3: Без кэширования

**Рассмотрено:** Всегда читать из БД напрямую.

**Отклонено:** Слишком высокая нагрузка на БД при частых запросах. Cache-aside оптимизирует производительность без потери надежности.

## Связанные документы

- [`../database-architecture.md`](../database-architecture.md) - архитектура БД с описанием cache-aside паттерна
- [`0001-canonical-database-tables.md`](./0001-canonical-database-tables.md) - канонические таблицы как источник истины
- [`../../../apps/api/src/repositories/projects-repository.ts`](../../../apps/api/src/repositories/projects-repository.ts) - реализация cache-aside в ProjectsRepository
- [`../../../apps/api/src/data/cache-manager.ts`](../../../apps/api/src/data/cache-manager.ts) - менеджер кэша
